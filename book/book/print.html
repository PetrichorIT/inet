<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>INET documentation</title>
    <meta name="robots" content="noindex">


    <!-- Custom HTML head -->

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter">
                    <li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong>
                            Overview</a></li>
                    <li>
                        <ol class="section">
                            <li class="chapter-item expanded "><a href="overview/setup.html"><strong
                                        aria-hidden="true">1.1.</strong> Project Setup</a></li>
                            <li class="chapter-item expanded "><a href="overview/basic-concepts.html"><strong
                                        aria-hidden="true">1.2.</strong> Basic concepts</a></li>
                        </ol>
                    </li>
                    <li class="chapter-item expanded "><a href="core.html"><strong aria-hidden="true">2.</strong> Core
                            functions</a></li>
                    <li>
                        <ol class="section">
                            <li class="chapter-item expanded "><a href="core/interface_mngmt.html"><strong
                                        aria-hidden="true">2.1.</strong> Interface managment</a></li>
                            <li class="chapter-item expanded "><a href="core/sending_algorithm.html"><strong
                                        aria-hidden="true">2.2.</strong> Conceptual sending algorithm</a></li>
                            <li class="chapter-item expanded "><a href="core/address_resolution.html"><strong
                                        aria-hidden="true">2.3.</strong> Address resolution</a></li>
                        </ol>
                    </li>
                </ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">INET documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
                        <p>INET is a framework build onto of the <code>des</code> simulation framework. INET provides a
                            networking implementations roughly based on the linux network stack. This includes
                            networking interface specifcation, including all relevant link layer protocol
                            implementations,
                            as well as full socket implementations, mirroring <code>tokio::net</code>.</p>
                        <h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
                        <p>As a networking implementations is rather large, INET is seperated into multiple crates:</p>
                        <ul>
                            <li><code>inet</code>: This is the core crate that provides a minmal version of all basic
                                functions of a networking stack,
                                including a UDP and TCP implementations and all types mirroring <code>tokio::net</code>
                            </li>
                            <li><code>inet-types</code>: This crate is a depedency of <code>inet</code> implementing
                                packet parsing and pure datatypes, often used
                                by upstream crates.</li>
                            <li><code>inet-bpg</code>: This crates implements the Border Gateway Protocol (BGP) and
                                provides routing deamons to integrate
                                BGP rules into the inet core module.</li>
                            <li><code>inet-rip</code>: Similarly, this crates implements the Routing Information
                                Protocol (RIP) and provides routing deamons to integrate
                                RIP rules into the inet core module.</li>
                            <li><code>inet-dns</code>: The core crate <code>inet</code>, does implement name lookups
                                using the <code>lookup_host</code> function, but by default, these lookups
                                do not result in DNS queries into the simulated network. This crate add both a local DNS
                                resolver that does send queries
                                as well as a DNS Nameserver implementation, to respond to these queries.</li>
                            <li><code>inet-pcap</code>: Debugging network applications can be rather complicated. To
                                make debugging easier this crate provides tools to
                                capture packets in the simulated network and export them as <code>.pcap</code> files
                                (<code>.pcapng</code> is also supported).</li>
                        </ul>
                        <h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
                        <p>Since INET is a networking framework, it obviously requires the feature <code>des/net</code>.
                            Additionally INET also requires
                            the feature <code>des/async</code>, since a significant part of the API in the core crate
                            such as <code>TcpStream</code> are async, just
                            like their <code>tokio</code> counterparts.</p>
                        <p>Additionally INET also requires the <code>--tokio-unstable</code> compile flag, inherited
                            from <code>des</code>, to remove randomness
                            from the underlying tokio runtime, thus archiving a fully deterministic network simulation.
                            To add this compile flag add
                            a <code>.cargo/config.toml</code> to your workspace:</p>
                        <pre><code>[build]
rustflags = ["--cfg", "tokio_unstable"]
</code></pre>
                        <h2 id="notice"><a class="header" href="#notice">Notice</a></h2>
                        <p>INET is still very early in development (&lt; 0.2.0), so expect things to break.</p>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
                        <p>INET integrates itself into the <code>des</code> runtime, as a root processing element
                            (called <code>IOPlugin</code>).
                            To avoid the need to add this module on every node, you should override the default
                            processing
                            elements of all nodes. INET provides a shorthand function to do this:</p>
                        <pre><pre class="playground"><code class="language-rust">fn main() {
    
    /* Build the simulation, run it, eat cookies */
}</code></pre>
                        </pre>
                        <p>This function should be called before anything else, since most parts of the INET API
                            depend on the existence of an instantiated <code>IOPlugin</code>. Should a module not
                            contain
                            this plugin, you will surely encounter an error message in the form:</p>
                        <pre><code>Custom { kind: Other, error: "Missing IOContext"
</code></pre>
                        <p>Note that INET uses <code>std::io::Error</code> as its error type, to ensure consitency with
                            both
                            <code>tokio::net</code> and <code>std::net</code> implementations.
                        </p>
                        <p>Once INET is initalized every module will be stared with a IOPlugin attached. This plugin
                            will capture
                            and possibly consume incoming messages, as part usual working of a networking stack. However
                            this
                            processing element will also ignore messages, clearly not intended for it. A freshly
                            initalized
                            IOPlugin will ignore almost all packets, expect:</p>
                        <ul>
                            <li>Messages with the message kind <code>KIND_LINK_UPDATE</code>, that also contain a
                                <code>LinkUpdate</code> struct as content
                            </li>
                            <li>Messages with the message kind <code>KIND_IO_TIMEOUT</code>, independent of content</li>
                        </ul>
                        <p>All other messages will be ignore in the inital configuration of an IO plugin. If you need to
                            send
                            other messages, ignored by the INET stack, the easiest solution is to avoid these two
                            message kinds.
                            If that is not possible, you can manually deactivate the IO plugin, by calling
                            <code>inet::deactivate</code>
                        </p>
                        <pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use des::prelude::*;
</span>struct MyModule;
impl Module for MyModule {
<span class="boring">    fn new() -&gt; Self { Self }
</span>    fn at_sim_start(&amp;mut self, _: usize) {
        inet::deactivate();
        schedule_in(Message::new().kind(KIND_IO_PLUGIN).build(), SimTime::ZERO);
    }

    fn handle_message(&amp;mut self, msg: Message) {
        assert_eq!(msg.kind(), KIND_IO_PLUGIN);
    }
}
<span class="boring">}</span></code></pre>
                        </pre>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
                        <p>As the previous chapter explained, an IO plugin without further configuration does almost
                            nothing.
                            This is intended. A network node without any network connection or any semblance of
                            connectivity
                            is useless. Additionally INET does not automatically use any gates of a module, without
                            explicitly
                            being told so. This enables user to restrict INET generated traffic to a select few gates.
                        </p>
                        <p>This chapter will discuss the basic concepts and configuration options from the perspective
                            of a
                            simple host.</p>
                        <blockquote>
                            <p>All references in this chapter refer to the API of the core crate <code>inet</code>. So
                                interpret <code>a::b</code> as <code>inet::a::b</code>.</p>
                        </blockquote>
                        <h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
                        <p>Any INET traffic is received and send by an <code>Interface</code>. An interface represents
                            the logical binding
                            between an <code>NetworkDevice</code>, capable of receiving or sending messages, and some
                            assigned addresses.
                            Network devices can either use a set of gates to receive and send messages, or just use
                            <code>schedule_in</code>
                            to send messages to itself, implementing a loopback interface. Addresses can be assigned to
                            interfaces
                            to act as both source addresses for outgoing packets, as well as target addresses incoming
                            addresses.
                            As soon as an address is assigned, INET will process packets address to the binding.
                        </p>
                        <p>Interfaces can be created in various ways, but the most basic case uses
                            <code>interfaces::add_interface</code>.
                            Various constructors allow for the creation if interfaces with preassigned address either
                            for IPv4
                            or IPv6. If user are ok with IPv6 only interfaces, <code>interfaces::Interface::empty</code>
                            is the easiest
                            solution, without a need to assign an address (IPv6 autoconfigures link local addresses +
                            stateless autocfg).
                        </p>
                        <p>The only component allways required to create an interface is a network device. These devices
                            should almost
                            allways be created using the same gate as both input and output (use
                            <code>interfaces::NetworkDevice::gate</code>). Providing
                            different gates is technically supported, but partically very hard to handle if both gates
                            do not exactly behave
                            equivalent to a single-gate solution. Additionally a network device expects the attached
                            gate chain to contain
                            at least one channel (must not be on the first chain link, but somewhere). Non-delayed
                            devices are also
                            allowed but emit warnings, since instantaneous networking is not expected by the current
                            standards.
                        </p>
                        <blockquote>
                            <p>A network device will only send onto non-busy channels, independently of any channel
                                buffers. If a burst of packets
                                needs to be send the IO plugin will rather buffer them internally. Also sending manual
                                messages to a gate-chain
                                administed by INET may lead to unexpected side effects in the IO plugin.</p>
                        </blockquote>
                        <h2 id="ethernet"><a class="header" href="#ethernet">Ethernet</a></h2>
                        <p>INET simulates ethernet traffic. This means that every message send by INET is either:</p>
                        <ul>
                            <li>a self scheduled message, either a <code>KIND_LINK_UPDATE</code> or a
                                <code>KIND_IO_TIMEOUT</code>
                            </li>
                            <li>or a networking packet representing an ethernet datagram</li>
                        </ul>
                        <p>The ethernet header is encoded directly into the <code>Message</code> struct itself, using
                            the
                            <code>src</code> and <code>dest</code> fields respectivly. The <code>MessageKind</code> is
                            used as the ETHERTYP field.
                            Other link layer effects such as packet collision or bit errors
                            are not supported, and likely never will be. The content of the message is any ethernet
                            encapsualed
                            payload INET can send. Currently that includes:
                        </p>
                        <ul>
                            <li>An <code>Ipv4Packet</code></li>
                            <li>An <code>ArpPacket</code></li>
                            <li>An <code>Ipv6Packet</code></li>
                        </ul>
                        <p>Note that all these packets are stored as is, rather then being serialized into bytevectors.
                            For now this is done, to improve performance and increase debuggabilty. Anything within a
                            IP packet is however serialized.</p>
                        <h2 id="async-socket-api"><a class="header" href="#async-socket-api">Async Socket API</a></h2>
                        <p>The primary "product" of the core crate are the async socket implementations, mirroring
                            <code>tokio::net</code>.
                            These sockets can be used just like their tokio counterparts, assuming an interface is
                            adequatly configured
                            The IO plugin will then consume any UDP or TCP packets and reroute their contents into the
                            async API,
                            finally being forwarded to the user as the result of read/write calls to the socket object.
                            Both
                            the UDP and TCP implementation are RFC compliant and fully featured, however without OS
                            specific
                            optimizations.
                        </p>
                        <pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use inet::TcpStream;
// in `at_sim_start`
tokio::spawn(async move {
    let sock = TcpStream::connect("192.168.0.103:8000").await?;
    sock.write(b"Hello world").await?;

    let mut buf = [0; 128];
    sock.read(&amp;mut buf).await?;
    assert_eq!(String::from_utf8_lossy(&amp;buf), "Hello back");
});
<span class="boring">}</span></code></pre>
                        </pre>
                        <h2 id="configuration-functions"><a class="header" href="#configuration-functions">Configuration
                                functions</a></h2>
                        <p>Almost all components of the networking stack have associated configurations, that
                            can be changed using the appropiate function in the API. The implications of changing
                            a config mid-flight is discussed seperatedly for each component.</p>
                        <h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
                        <p>INET fully supports <code>tracing</code> and with a scope aware logger, provided by
                            <code>des::tracing</code>, also scope
                            aware traces of internal computations. As a general rule, INET does not emit INFO level
                            events, only
                            DEBUG and TRACE level events. Should an error occure internally INET may also emit WARN and
                            ERROR level
                            events, but this only includes major failures, that may be of interest to the user, not
                            minor failures
                            like a failed address resolution.
                        </p>
                        <p>Should tracing not suffice, INET also enables packet captures with the feature flag
                            <code>libpcap</code> and the
                            <code>inet-pcap</code> crate. See [TODO] for more infomation.
                        </p>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="core-functions"><a class="header" href="#core-functions">Core functions</a></h1>
                        <p>This chaper will further explain the functionality implemented in
                            the core crate <code>inet</code>.</p>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="interface-management"><a class="header" href="#interface-management">Interface
                                Management</a></h1>
                        <p>This chapter will explain all detail regarding interface management,
                            configuration and the automatic procedures that may are associted to
                            basic interface to interface communication.</p>
                        <h2 id="parts-of-the-machine"><a class="header" href="#parts-of-the-machine">Parts of the
                                machine</a></h2>
                        <p>An interface can be roughtly described as a collection of the following datapoints:</p>
                        <ul>
                            <li>A host-unique interface name (such as <code>en0</code>)</li>
                            <li>A set of flags, indicating the capabilites and the role of the interface
                                independent of the underlying device</li>
                            <li>A set of assigned IPv4 addresses</li>
                            <li>A set of assigned IPv6 addresses as well as some multicast groups</li>
                            <li>A network device, with an associated MAC addresss</li>
                        </ul>
                        <p>All these components define how a interface will behave if it deals
                            with both outgoing and incoming traffic. At runtime, an interface
                            also directly manages:</p>
                        <ul>
                            <li>Buffers to queue packages, to prevent the overloading of underlying channels</li>
                            <li>Status information about the current sending process</li>
                            <li>Statistics about the traffic send to this interface</li>
                        </ul>
                        <p>Additionaly some other processes are associted to interface management and
                            link-local connectivity. This includes:</p>
                        <ul>
                            <li>Link layer address resolution (via ARP for IPv4 or NDP for IPv6)</li>
                            <li>Stateless address autoconfiguration for IPv6</li>
                            <li>Multicast listener discovery for IPv6</li>
                        </ul>
                        <h2 id="network-devices"><a class="header" href="#network-devices">Network devices</a></h2>
                        <p>A network device connects the IO plugin to some kind of connectivity, provided by the
                            simulation.
                            There are two kinds of network devices:</p>
                        <ul>
                            <li><code>Loopback</code> devices, use the <code>schedule_in</code>/<code>schedule_at</code>
                                API to allow a node to send messages to itself. Loopback links
                                are never delayed, so the effective latency is <code>0ms</code> and the bitrate is
                                infinite.</li>
                            <li><code>Ethernet</code> devices, use a pair of gates as both input and output to send and
                                receive messages. Incoming messages are
                                assigned to the ethernet device that matches the <code>last_gate</code> header in the
                                incoming message. The output gate
                                is used to send out message. If a channel is attached to the output link (directly or
                                indirectly) the interface
                                will only send messages as long as the channel is not busy. Note that a ethenert device
                                will not send the next
                                packet immieditatly after the last, but rather introduces a <code>1ns</code> delay to
                                prevent event collisions.</li>
                        </ul>
                        <p>Each network device is assigned a MAC address. MAC addresses are randomly generated by
                            <code>des</code>, so their uniqueness is
                            not guaranteed, but highly likely. The <code>addr</code> field of a network device can also
                            be changed, to create devices with
                            fixed MAC addresses.
                        </p>
                        <p>Each interface only accepts ethernet datagrams addressed to one of the following addresses:
                        </p>
                        <ul>
                            <li>The exact MAC address of the receiving device</li>
                            <li>The broadcast address <code>ff:ff:ff:ff:ff:ff</code></li>
                            <li>A matching multicast address for an existing multicast binding on the interface
                                (<code>33:33:xx:xx:xx:xx</code>)</li>
                        </ul>
                        <h2 id="interface-flags"><a class="header" href="#interface-flags">Interface flags</a></h2>
                        <p>The interface flags indicate the capabilites and role of a interface. Since underlying device
                            can neither enforce nor describe diverging usage patters such as p2p only links or simplex
                            connections,
                            flags can be used to enforce compliant behaviour to these operations.</p>
                        <p>Currently only a few flags are activly supported:</p>
                        <ul>
                            <li><code>multicast</code> indicates that a interface is multicast capable. Most interface
                                functions require a multicast capable interface
                                so no setting this flag can break many things.</li>
                            <li><code>broadcast</code> indicates the of the attached link to propagate broadcast
                                packets. This can be a minimally viable solution for
                                IPv4 networks without multicast capabilites.</li>
                            <li><code>router</code> indicates that the node should act as a router in regards to this
                                interface. This includes not only routing incoming
                                packets, but also responding to NDP router solicitations, as well as acting as a MLD
                                Querier.</li>
                            <li><code>v6</code> indicates that the interface is IPv6 capable. If this flag is not set,
                                the interface only supports IPv4 traffic.
                                (Impl not yet complete)</li>
                        </ul>
                        <h2 id="assigning-ipv4-addresses"><a class="header" href="#assigning-ipv4-addresses">Assigning
                                IPv4 addresses</a></h2>
                        <p>Any binding of an IPv4 address requires both a address and a netmask to bind the interface to
                            a local network segment. IPv4 bindings will be valid without any lookups into the local
                            network
                            since no dedup is currently implemented for IPv4 bindings.</p>
                        <h2 id="assigning-ipv6-addresss"><a class="header" href="#assigning-ipv6-addresss">Assigning
                                IPv6 addresss</a></h2>
                        <p>Each IPv6 capable interface guarantees the existence of a link-local IPv6 address, derived
                            from the
                            network device's MAC address (direct derive, not updated to secure generation). Additionally
                            the user can provide other binding either directly as part of the <code>Interface</code>
                            when calling
                            <code>intefaces::add_interface</code> or using <code>intefaces::interface_add_addr</code>.
                            Any newly assigned address
                            will not be assigned immediatly, but rather be checked for duplicates in the local network
                            segment.
                            After this deduplication succeeds the address will be assigned, including the apporpiate
                            multicast
                            bindings.
                        </p>
                        <p>Address deduplication can take up to <code>NDP_MAX_RTR_SOLICITATION_DELAY</code> seconds.
                            Address deduplication can be
                            deactivated by setting the host configuration variable
                            <code>dup_addr_detect_transmits</code> to <code>0</code>. Use the configuration
                            API at <code>ipv6::api::set_node_cfg</code> to change the host configuration.
                        </p>
                        <p>Should the deduplication fail, the address will not be assigned. An error is not yet
                            emitteded (TODO), but a
                            log is created.</p>
                        <p>Besides manually assigninga addresses, a IPv6 capable interface will also use stateless
                            address autoconfiguration
                            to discover the local network prefixes and assign addresses accordingly. This requires the
                            presence of a IPv6
                            capable router in the local network segement. Address deduplication is also performed for
                            these addresses.</p>
                        <h2 id="buffering"><a class="header" href="#buffering">Buffering</a></h2>
                        <p>When an interface sends packet bursts, packets may be buffered in the interface, so not
                            overload the
                            channel. An interface will buffer up to a fixed amount of packets, no more. If no more
                            packets
                            can be stored the interface will:</p>
                        <p>a) Assert backpressure to slow down the sending component
                            b) Drop any packets still queued for sending after that</p>
                        <p>Not all components are able to react to backpressure, but the TCP implementation can.
                            Other sockets like like <code>UdpSocket</code> or <code>RawIpSocket</code> cannot directly
                            react to backpressure,
                            but interface sending errors may be propagated to the send call.</p>
                        <h2 id="api"><a class="header" href="#api">API</a></h2>
                        <p>These are the components of the interface API:</p>
                        <ul>
                            <li>
                                <p><code>Interface</code> is the base struct, to create new interfaces</p>
                                <ul>
                                    <li>it contains <code>InterfaceFlags</code> as described aboth</li>
                                    <li>it contains <code>InterfaceAddrs</code> to manage address assigments</li>
                                    <li>it contains an <code>InterfaceName</code> to uniquly identifiy the interface for
                                        the current host</li>
                                    <li>it contains a <code>NetworkDevice</code> to manage the underlying connectivity
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p><code>add_interface</code> adds an interface to the node</p>
                                <ul>
                                    <li>it only requires an instance of <code>Interface</code> to allocate a new IO
                                        binding</li>
                                    <li>if this function returns with <code>Ok(())</code>, this only indicates that the
                                        interface has been created
                                        and the configuration was plausible. It may be the case that addresses are not
                                        yet assigned since
                                        they are not yet deduplicated.</li>
                                </ul>
                            </li>
                            <li>
                                <p><code>interface_add_addr</code> assigns a new address binding to an interface</p>
                                <ul>
                                    <li>similarly <code>Ok(())</code> does not indicate that dedup succeeded, only that
                                        the
                                        assigment process has begun</li>
                                </ul>
                            </li>
                            <li>
                                <p><code>interface_status{, _by_id}</code> returns the simplified state of an interface
                                </p>
                                <ul>
                                    <li>this state can be exported as simulation parameters (see
                                        <code>des::net::par</code>) to
                                        propagate interface configuration results over node bounds
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>configuration functions for NDP, MLD and the general host configuration are also
                                    relevant
                                    to interface managment, since these protocols are used as port of the automatic
                                    configuration
                                    process</p>
                            </li>
                        </ul>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="a-conceptual-sending-algorithm"><a class="header"
                                href="#a-conceptual-sending-algorithm">A conceptual sending algorithm</a></h1>
                        <p>With the knowledge of previous chapters, lest discuss a conceptual sending algorithm,
                            starting from the async API ending at send packets.</p>
                        <h2 id="ip-version-4"><a class="header" href="#ip-version-4">IP Version 4</a></h2>
                        <p>TODO</p>
                        <h2 id="ip-version-6"><a class="header" href="#ip-version-6">IP Version 6</a></h2>
                        <blockquote>
                            <p>Szenario:
                                Sending a TCP Data packet on an allready open TCP connection</p>
                        </blockquote>
                        <ol>
                            <li>The user calls into the async API using e.g. <code>AsyncWrite::write</code> on a
                                <code>TcpStream</code>
                                <ul>
                                    <li>This call will be forwarded to the IO plugin (if one exists), and the relevant
                                        TCP component</li>
                                    <li>The TCP component will add the new data to its buffers and then emit the
                                        underlying
                                        IP packet needed to facilitate the TCP connection</li>
                                </ul>
                            </li>
                            <li>The TCP component emits an <code>IPv6Packet</code> to the IP stack
                                <ul>
                                    <li>let's assume that the IP source address is <code>::</code> but the IP
                                        destination address is a known unicast address</li>
                                    <li>let's also assume that the socket is not pinned to a specific interface, but
                                        rather able to use all interfaces
                                        of the host</li>
                                </ul>
                            </li>
                            <li>The IP stack will first check the destination address: If the destination address is
                                <code>::</code> the sending will fail
                            </li>
                            <li><strong>If</strong> the IP source address is unspecified, a source address will be
                                selected according to the source
                                address selection mechanisms defined by RFC 6724.
                                <ul>
                                    <li>This process depends on three variables: The available addresses, the policies
                                        table and the given destination address</li>
                                    <li>For some rare cases, the IP stack also allows <code>::</code> as a valid source
                                        address, e.g. for NDP Neighbor solicitations</li>
                                </ul>
                            </li>
                            <li><strong>If</strong> the packet is address to the node itself, so its addressed to self,
                                the IP stack will emit the packet onto the input
                                gate of the relevant interface for ethernet devices, or just send it using a loopback
                                device.</li>
                            <li><strong>If</strong> no interface binding was specified, the IP stack will determine the
                                sending interface based on the choosen source
                                address.
                                <ul>
                                    <li>Sending packets with IP source address <code>::</code> thus allways requires a
                                        specified interface binding.</li>
                                </ul>
                            </li>
                            <li>Next the IP stack will determine the next hop required to reach the destintation
                                address.
                                <ul>
                                    <li>On hosts this only check whether the destination is on-link or off-link. Off
                                        link destintations are forwarded to
                                        a router from the default router list.</li>
                                    <li>On routers, this table contains the fowarding rules, derived from the routing
                                        rules of associated routing deamons.</li>
                                    <li>Not that next-hop determination results are cached in the destination cache, so
                                        lookups into the raw tables are avoided
                                        whenever possible</li>
                                </ul>
                            </li>
                            <li>After the next hop is determined, the link-layer address resolution will start. The IP
                                stack will lookup the MAC address of
                                the next hop. <strong>If</strong> no address is known, the node will send neighbor
                                solicitations using NDP and queue the packet for later delivery.
                                <ul>
                                    <li>Should this fail, the packets will be dropped and an error will be emitted if
                                        higher level components are able to handle the error</li>
                                </ul>
                            </li>
                            <li>With the determined link layer destination the IP packet is encapuslated into a ethernet
                                datagram (via <code>Message</code>) and forwarded to
                                the sending interface. The interface will emit the datagram onto the underlying
                                connections as soon as possible</li>
                        </ol>
                        <div style="break-before: page; page-break-before: always;"></div>
                        <h1 id="address-resolution"><a class="header" href="#address-resolution">Address resolution</a>
                        </h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>

    </div>
</body>

</html>