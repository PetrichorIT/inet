# Interface Management

This chapter will explain all detail regarding interface management,
configuration and the automatic procedures that may are associted to
basic interface to interface communication.

## Parts of the machine

An interface can be roughtly described as a collection of the following datapoints:

- A host-unique interface name (such as `en0`)
- A set of flags, indicating the capabilites and the role of the interface 
  independent of the underlying device
- A set of assigned IPv4 addresses
- A set of assigned IPv6 addresses as well as some multicast groups
- A network device, with an associated MAC addresss

All these components define how a interface will behave if it deals
with both outgoing and incoming traffic. At runtime, an interface
also directly manages:

- Buffers to queue packages, to prevent the overloading of underlying channels
- Status information about the current sending process
- Statistics about the traffic send to this interface

Additionaly some other processes are associted to interface management and
link-local connectivity. This includes:

- Link layer address resolution (via ARP for IPv4 or NDP for IPv6)
- Stateless address autoconfiguration for IPv6
- Multicast listener discovery for IPv6

## Network devices

A network device connects the IO plugin to some kind of connectivity, provided by the simulation.
There are two kinds of network devices:
- `Loopback` devices, use the `schedule_in`/`schedule_at` API to allow a node to send messages to itself. Loopback links
  are never delayed, so the effective latency is `0ms` and the bitrate is infinite.
- `Ethernet` devices, use a pair of gates as both input and output to send and receive messages. Incoming messages are
  assigned to the ethernet device that matches the `last_gate` header in the incoming message. The output gate
  is used to send out message. If a channel is attached to the output link (directly or indirectly) the interface
  will only send messages as long as the channel is not busy. Note that a ethenert device will not send the next
  packet immieditatly after the last, but rather introduces a `1ns` delay to prevent event collisions.

Each network device is assigned a MAC address. MAC addresses are randomly generated by `des`, so their uniqueness is
not guaranteed, but highly likely. The `addr` field of a network device can also be changed, to create devices with
fixed MAC addresses.

Each interface only accepts ethernet datagrams addressed to one of the following addresses:

- The exact MAC address of the receiving device
- The broadcast address `ff:ff:ff:ff:ff:ff`
- A matching multicast address for an existing multicast binding on the interface (`33:33:xx:xx:xx:xx`)

## Interface flags

The interface flags indicate the capabilites and role of a interface. Since underlying device
can neither enforce nor describe diverging usage patters such as p2p only links or simplex connections,
flags can be used to enforce compliant behaviour to these operations.

Currently only a few flags are activly supported:
- `multicast` indicates that a interface is multicast capable. Most interface functions require a multicast capable interface
  so no setting this flag can break many things.
- `broadcast` indicates the of the attached link to propagate broadcast packets. This can be a minimally viable solution for
  IPv4 networks without multicast capabilites.
- `router` indicates that the node should act as a router in regards to this interface. This includes not only routing incoming
  packets, but also responding to NDP router solicitations, as well as acting as a MLD Querier.
- `v6` indicates that the interface is IPv6 capable. If this flag is not set, the interface only supports IPv4 traffic.
  (Impl not yet complete)

## Assigning IPv4 addresses

Any binding of an IPv4 address requires both a address and a netmask to bind the interface to 
a local network segment. IPv4 bindings will be valid without any lookups into the local network
since no dedup is currently implemented for IPv4 bindings.

## Assigning IPv6 addresss

Each IPv6 capable interface guarantees the existence of a link-local IPv6 address, derived from the 
network device's MAC address (direct derive, not updated to secure generation). Additionally
the user can provide other binding either directly as part of the `Interface` when calling
`intefaces::add_interface` or using `intefaces::interface_add_addr`. Any newly assigned address
will not be assigned immediatly, but rather be checked for duplicates in the local network segment.
After this deduplication succeeds the address will be assigned, including the apporpiate multicast
bindings.

Address deduplication can take up to `NDP_MAX_RTR_SOLICITATION_DELAY` seconds. Address deduplication can be
deactivated by setting the host configuration variable `dup_addr_detect_transmits` to `0`. Use the configuration 
API at `ipv6::api::set_node_cfg` to change the host configuration.

Should the deduplication fail, the address will not be assigned. An error is not yet emitteded (TODO), but a 
log is created.

Besides manually assigninga addresses, a IPv6 capable interface will also use stateless address autoconfiguration
to discover the local network prefixes and assign addresses accordingly. This requires the presence of a IPv6
capable router in the local network segement. Address deduplication is also performed for these addresses.

## Buffering

When an interface sends packet bursts, packets may be buffered in the interface, so not overload the
channel. An interface will buffer up to a fixed amount of packets, no more. If no more packets
can be stored the interface will:

a) Assert backpressure to slow down the sending component 
b) Drop any packets still queued for sending after that

Not all components are able to react to backpressure, but the TCP implementation can.
Other sockets like like `UdpSocket` or `RawIpSocket` cannot directly react to backpressure,
but interface sending errors may be propagated to the send call.

## API

These are the components of the interface API:

- `Interface` is the base struct, to create new interfaces
  - it contains `InterfaceFlags` as described aboth
  - it contains `InterfaceAddrs` to manage address assigments
  - it contains an `InterfaceName` to uniquly identifiy the interface for the current host
  - it contains a `NetworkDevice` to manage the underlying connectivity
- `add_interface` adds an interface to the node
  - it only requires an instance of `Interface` to allocate a new IO binding
  - if this function returns with `Ok(())`, this only indicates that the interface has been created
    and the configuration was plausible. It may be the case that addresses are not yet assigned since
    they are not yet deduplicated.
- `interface_add_addr` assigns a new address binding to an interface
  - similarly `Ok(())` does not indicate that dedup succeeded, only that the
    assigment process has begun
- `interface_status{, _by_id}` returns the simplified state of an interface
  - this state can be exported as simulation parameters (see `des::net::par`) to
    propagate interface configuration results over node bounds

- configuration functions for NDP, MLD and the general host configuration are also relevant
  to interface managment, since these protocols are used as port of the automatic configuration
  process